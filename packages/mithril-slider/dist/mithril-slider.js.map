{"version":3,"file":"mithril-slider.js","sources":["../src/prop.js","../src/classes.js","../src/index.js","../src/touch.js","../src/css.js"],"sourcesContent":["\nexport default x => {\n  let p = x;\n  return args => {\n    if (args === undefined) {\n      return p;\n    } else {\n      p = args;\n    }\n  };\n};\n","\nexport const classes = {\n  slider:    \"mithril-slider\",\n  content:   \"mithril-slider__content\",\n  before:    \"mithril-slider__before\",\n  after:     \"mithril-slider__after\"\n};\n","import m from \"mithril\";\nimport prop from \"./prop\";\nimport { Touch } from \"./touch\";\nimport { classes } from \"./classes\";\n\nconst DEFAULT_DURATION = 160;\nconst DEFAULT_CANCEL_DRAG_FACTOR = 1 / 5;\nconst DEFAULT_GROUP_SIZE = 1;\nconst DEFAULT_ORIENTATION = \"vertical\";\nconst DEFAULT_DIRECTION = 1;\nconst DEFAULT_OFFSET_X = 0;\nconst DEFAULT_OFFSET_Y = 0;\n\nconst view = ({state, attrs}) => {\n  if (attrs.sliderController) {\n    attrs.sliderController(state);\n  }\n  if (state.inited) {\n    if (state.rescaleRequired) {\n      state.rescaleRequired = false;\n      state.goCurrent();\n      m.redraw();\n    }\n  }\n\n  const currentIndex = state.index();\n  // sizes need to be set each redraw because of screen resizes\n  state.groupBy(attrs.groupBy || 1);\n  const contentEl = state.contentEl;\n  if (contentEl) {\n    state.updateContentSize(contentEl);\n  }\n  return m(\"div\",\n    {\n      class: [\n        classes.slider,\n        attrs.class || \"\"\n      ].join(\" \")\n    },\n    [\n      attrs.before\n        ? m(\".\" + classes.before, attrs.before)\n        : null,\n      m(\"div\",\n        {\n          class: classes.content,\n          onupdate: ({dom}) => {\n            if (state.inited) {\n              return;\n            }\n            if (dom.childNodes.length > 0) {\n              state.setContentEl(dom);\n              state.updateContentSize(dom);\n              state.touch = new Touch({\n                el: dom,\n                orientation: attrs.orientation,\n                onStart: state.handleDragStart,\n                onMove: state.handleDrag,\n                onEnd: state.handleDragEnd\n              });\n              state.inited = true;\n            }\n          },\n          onremove: () => state.touch && state.touch.destroy()\n        },\n        state.list().map((data, listIndex) =>\n          attrs.page({\n            data,\n            listIndex,\n            currentIndex\n          })\n        )\n      ),\n      attrs.after\n        ? m(\".\" + classes.after, attrs.after)\n        : null\n    ]\n  );\n};\n\nconst oninit = vnode => {\n  const attrs = vnode.attrs;\n  const list = prop([]);\n  if (attrs.pageData) {\n    attrs.pageData().then(result => initWithResult(result));\n  }\n  const duration = parseInt(attrs.duration, 10) || DEFAULT_DURATION;\n  const index = prop(attrs.index || -1);\n  let contentEl;\n  let pageSize = 0;\n  const groupBy = prop(attrs.groupBy || DEFAULT_GROUP_SIZE);\n  const cancelDragFactor = attrs.cancelDragFactor || DEFAULT_CANCEL_DRAG_FACTOR;\n  const isVertical = attrs.orientation === DEFAULT_ORIENTATION;\n  const dir = attrs.rtl ? -1 : DEFAULT_DIRECTION;\n  const pageOffsetX = attrs.pageOffsetX || DEFAULT_OFFSET_X;\n  const pageOffsetY = attrs.pageOffsetY || DEFAULT_OFFSET_Y;\n\n  const centerCurrent = attrs.centerCurrent || false;\n  const containerSize = prop(0);\n  let finishedDrag = 0;\n\n  const initWithResult = result => {\n    list(result);\n    // First redraw so that pages are drawn\n    // continuation in view's oncreate\n    m.redraw();\n  };\n\n  const setIndex = idx => {\n    const oldIndex = index();\n    if (oldIndex !== idx) {\n      index(idx);\n      m.redraw();\n      if (attrs.getState) {\n        const el = contentEl;\n        const page = getPageEl(el, index());\n        attrs.getState({\n          index: idx,\n          hasNext: hasNext(),\n          hasPrevious: hasPrevious(),\n          pageEl: page\n        });\n      }\n    }\n  };\n\n  const getPageEl = (el, idx) => el.childNodes[idx];\n\n  const createAttrs = value => {\n    const x = isVertical ? \"0\" : value + \"px\";\n    const y = isVertical ? value + \"px\" : \"0\";\n    const z = \"0\";\n    const attrs = [x, y, z].join(\", \");\n    return \"translate3d(\" + attrs + \")\";\n  };\n\n  const setTransitionStyle = (el, value) => {\n    const style = el.style;\n    style.transform = style[\"-webkit-transform\"] = style[\"-moz-transform\"] = style[\"-ms-transform\"] = createAttrs(value);\n  };\n\n  const setTransitionDurationStyle = duration => {\n    contentEl.style[\"-webkit-transition-duration\"] = contentEl.style[\"transition-duration\"] = duration + \"ms\";\n  };\n\n  const getOffset = (idx) => {\n    if (centerCurrent && idx>=0) {\n      const pageToCenter = contentEl.children[ idx ];\n      if (pageToCenter) {\n        if (containerSize() === 0) {\n          // The mithril-slider element\n          const mithrilSlider = contentEl.parentElement;\n          if (mithrilSlider) {\n            const container = mithrilSlider.parentElement;\n            if (container) {\n              containerSize( isVertical ? container.clientHeight : container.clientWidth );\n            }\n          }\n        }\n        if (containerSize() !== 0) {\n          if (isVertical) {\n            return (containerSize() / 2 - pageToCenter.offsetHeight / 2) - pageToCenter.offsetTop;\n          } else {\n            return (containerSize() / 2 - pageToCenter.offsetWidth / 2) - pageToCenter.offsetLeft;\n          }\n        }\n      }\n      vnode.state.rescaleRequired = true;\n    }\n    return -dir * idx * pageSize;\n  }\n\n  const goTo = (idx, duration) => {\n    // Prevent a \"goTo\" within 300ms of a drag completion\n    // Otherwise the drag can trigger a click event that\n    // selects the wrong item.\n    const now = Date.now();\n    if (now - finishedDrag < 300) {\n      return;\n    }\n    if (idx < 0 || idx > list().length - 1) {\n      return;\n    }\n    updateContentSize(contentEl);\n    if (duration !== undefined) {\n      setTransitionDurationStyle(duration);\n    }\n    setTransitionStyle(contentEl, getOffset(idx));\n    setIndex(idx);\n  };\n\n  const normalizedStep = (orientation = 0) => {\n    const idx = index();\n    const size = groupBy();\n    const min = 0;\n    const max = list().length;\n    const next = idx + (orientation * size);\n    // make sure that last item aligns at the right\n    if ((next + size) > max) {\n      return max - size;\n    }\n    if (next < min) {\n      return min;\n    }\n    return next;\n  };\n\n  const updateContentSize = el => {\n    const prop = isVertical ? \"height\" : \"width\";\n    const page = el.childNodes[0];\n    if (page.getBoundingClientRect()[prop]) {\n      pageSize = page.getBoundingClientRect()[prop];\n    }\n    if (attrs.dynamicSizePages) {\n      const contentSize = [...el.childNodes].reduce(\n        (accumulator, node) =>\n          accumulator + node.getBoundingClientRect()[prop],\n        0);\n      el.style[prop] = contentSize + \"px\";\n    } else {\n      el.style[prop] = (list().length * pageSize) + \"px\";\n    }\n  };\n\n  const goCurrent = (duration = 0) => {\n    updateContentSize(contentEl);\n    setTransitionDurationStyle(duration);\n    goTo(normalizedStep());\n  };\n\n  const goNext = (dur = duration) => (\n    setTransitionDurationStyle(dur),\n    index() < list().length ? goTo(normalizedStep(1)) : goTo(normalizedStep())\n  );\n\n  const goPrevious = (dur = duration) => (\n    setTransitionDurationStyle(dur),\n    index() > 0 ? goTo(normalizedStep(-1)) : goTo(normalizedStep())\n  );\n\n  const hasNext = () => index() + groupBy() < list().length;\n\n  const hasPrevious = () => index() > 0;\n\n  const setContentEl = el => {\n    contentEl = el;\n    updateContentSize(el);\n    goCurrent();\n  };\n\n  const handleDragStart = () => (\n    updateContentSize(contentEl),\n    setTransitionDurationStyle(0)\n  );\n\n  const handleDrag = e => {\n    const el = contentEl;\n    const delta = isVertical\n      ? e.deltaY + pageOffsetY\n      : e.deltaX + pageOffsetX;\n    const origin = getOffset(index());\n    setTransitionStyle(el, delta + origin);\n    e.preventDefault();\n  };\n\n  const calculateTransitionDuration = velocity => {\n    const el = contentEl;\n    const page = getPageEl(el, index());\n    const width = page.clientWidth;\n    const speed = Math.abs(velocity) || 1;\n    let dur = 1 / speed * width;\n    if (dur > duration) {\n      dur = duration;\n    }\n    return dur;\n  };\n\n  const handleDragEnd = e => {\n    const dur = calculateTransitionDuration(e.velocity);\n    let delta = isVertical ? e.deltaY : e.deltaX;\n    if (Math.abs(delta) > pageSize * groupBy() * cancelDragFactor) {\n      if (dir * delta < 0) {\n        while ((dir * delta) < 0) {\n          goNext(dur);\n          delta += dir * pageSize * groupBy();\n        }\n      } else {\n        while ((dir * delta) > 0) {\n          goPrevious(dur);\n          delta -= dir * pageSize * groupBy();\n        }\n      }\n      vnode.state.rescaleRequired = true;\n      m.redraw();\n    } else {\n      goCurrent(dur);\n    }\n    finishedDrag = Date.now();\n  };\n\n  Object.assign(vnode.state, {\n    // component methods\n    list,\n    setContentEl,\n    handleDrag,\n    handleDragStart,\n    handleDragEnd,\n    groupBy,\n    updateContentSize,\n\n    // public interface\n    index,\n    hasNext,\n    hasPrevious,\n    goTo,\n    goCurrent,\n    goNext,\n    goPrevious\n  });\n};\n\nexport const slider = {\n  oninit,\n  view\n};\n","/* global Hammer */\nimport \"hammerjs\";\n\nexport const Touch = ({ el, orientation, onStart, onMove, onEnd }) => {\n  const hammer = new Hammer.Manager(el, {});\n  hammer.add(new Hammer.Pan({\n    direction: orientation === \"vertical\"\n      ? Hammer.DIRECTION_VERTICAL\n      : orientation === \"all\"\n        ? Hammer.DIRECTION_ALL\n        : Hammer.DIRECTION_HORIZONTAL,\n    threshold: 0\n  }));\n  hammer.on(\"panstart\", onStart);\n  hammer.on(\"panmove\", onMove);\n  hammer.on(\"panend\", onEnd);\n\n  return {\n    destroy: () => {\n      hammer.off(\"panstart\", onStart);\n      hammer.off(\"panmove\", onMove);\n      hammer.off(\"panend\", onEnd);\n    }\n  };\n};","\nexport const css = [{\n  \".mithril-slider\": {\n    overflow: \"hidden\",\n\n    \" .mithril-slider__content\": {\n      transitionProperty: \"transform\",\n      transitionTimingFunction: \"ease-out\",\n      // transition-duration set in js\n      transform: \"translate3d(0, 0, 0)\"\n    }\n  }\n}];\n\n"],"names":["p","x","undefined","args","classes","slider","attrs","vnode","list","prop","pageData","then","initWithResult","result","duration","parseInt","index","contentEl","pageSize","groupBy","cancelDragFactor","isVertical","orientation","dir","rtl","pageOffsetX","pageOffsetY","centerCurrent","containerSize","finishedDrag","redraw","getPageEl","el","idx","childNodes","setTransitionStyle","value","style","transform","join","createAttrs","setTransitionDurationStyle","getOffset","pageToCenter","children","mithrilSlider","parentElement","container","clientHeight","clientWidth","offsetHeight","offsetTop","offsetWidth","offsetLeft","state","rescaleRequired","goTo","Date","now","length","getState","page","hasNext","hasPrevious","normalizedStep","size","max","next","updateContentSize","getBoundingClientRect","dynamicSizePages","contentSize","reduce","accumulator","node","goCurrent","goNext","dur","goPrevious","delta","e","deltaY","deltaX","origin","preventDefault","width","Math","abs","velocity","calculateTransitionDuration","sliderController","inited","currentIndex","m","class","before","content","dom","setContentEl","touch","onStart","onMove","onEnd","hammer","Hammer","Manager","add","Pan","DIRECTION_VERTICAL","DIRECTION_ALL","DIRECTION_HORIZONTAL","on","off","handleDragStart","handleDrag","handleDragEnd","destroy","map","data","listIndex","after"],"mappings":"6TACA,sBACMA,EAAIC,SACD,oBACQC,IAATC,SACKH,IAEHG,ICNGC,UACA,yBACA,iCACA,+BACA,6LC4TAC,UAjPE,gBACPC,EAAQC,EAAMD,MACdE,EAAOC,MACTH,EAAMI,YACFA,WAAWC,KAAK,mBAAUC,EAAeC,SAE3CC,EAAWC,SAAST,EAAMQ,SAAU,KAjFnB,IAkFjBE,EAAQP,EAAKH,EAAMU,QAAU,GAC/BC,SACAC,EAAW,EACTC,EAAUV,EAAKH,EAAMa,SAnFF,GAoFnBC,EAAmBd,EAAMc,kBArFE,GAsF3BC,EApFoB,aAoFPf,EAAMgB,YACnBC,EAAMjB,EAAMkB,KAAO,EApFD,EAqFlBC,EAAcnB,EAAMmB,aApFH,EAqFjBC,EAAcpB,EAAMoB,aApFH,EAsFjBC,EAAgBrB,EAAMqB,gBAAiB,EACvCC,EAAgBnB,EAAK,GACvBoB,EAAe,EAEbjB,EAAiB,cAChBC,KAGHiB,UAqBEC,EAAY,SAACC,EAAIC,UAAQD,EAAGE,WAAWD,IAUvCE,EAAqB,SAACH,EAAII,OACxBC,EAAQL,EAAGK,QACXC,UAAYD,EAAM,qBAAuBA,EAAM,kBAAoBA,EAAM,iBAV7D,kBAKX,gBAJGhB,EAAa,IAAMe,EAAQ,KAC3Bf,EAAae,EAAQ,KAAO,IAC5B,KACcG,KAAK,MACG,IAKkEC,CAAYJ,IAG1GK,EAA6B,cACvBJ,MAAM,+BAAiCpB,EAAUoB,MAAM,uBAAyBvB,EAAW,MAGjG4B,EAAY,SAACT,MACbN,GAAiBM,GAAK,EAAG,KACrBU,EAAe1B,EAAU2B,SAAUX,MACrCU,EAAc,IACQ,IAApBf,IAAuB,KAEnBiB,EAAgB5B,EAAU6B,iBAC5BD,EAAe,KACXE,EAAYF,EAAcC,cAC5BC,KACa1B,EAAa0B,EAAUC,aAAeD,EAAUE,iBAI7C,IAApBrB,WACEP,EACMO,IAAkB,EAAIe,EAAaO,aAAe,EAAKP,EAAaQ,UAEpEvB,IAAkB,EAAIe,EAAaS,YAAc,EAAKT,EAAaU,aAI3EC,MAAMC,iBAAkB,SAExBhC,EAAMU,EAAMf,GAGhBsC,EAAO,SAACvB,EAAKnB,GAIL2C,KAAKC,MACP7B,EAAe,KAGrBI,EAAM,GAAKA,EAAMzB,IAAOmD,OAAS,MAGnB1C,QACDf,IAAbY,KACyBA,KAEVG,EAAWyB,EAAUT,IA/EzB,eACEjB,MACAiB,MACTA,KACJH,SACExB,EAAMsD,UAAU,KAEZC,EAAO9B,EADFd,EACgBD,OACrB4C,gBACG3B,UACE6B,gBACIC,WACLF,MAoEL5B,KAGL+B,EAAiB,eAAC1C,yDAAc,EAC9BW,EAAMjB,IACNiD,EAAO9C,IAEP+C,EAAM1D,IAAOmD,OACbQ,EAAOlC,EAAOX,EAAc2C,SAE7BE,EAAOF,EAAQC,EACXA,EAAMD,EAEXE,EAPQ,EAAA,EAULA,GAGHC,EAAoB,gBAClB3D,EAAOY,EAAa,SAAW,QAC/BwC,EAAO7B,EAAGE,WAAW,MACvB2B,EAAKQ,wBAAwB5D,OACpBoD,EAAKQ,wBAAwB5D,IAEtCH,EAAMgE,iBAAkB,KACpBC,mIAAkBvC,EAAGE,aAAYsC,OACrC,SAACC,EAAaC,UACZD,EAAcC,EAAKL,wBAAwB5D,IAC7C,KACC4B,MAAM5B,GAAQ8D,EAAc,YAE5BlC,MAAM5B,GAASD,IAAOmD,OAASzC,EAAY,MAI5CyD,EAAY,eAAC7D,yDAAW,IACVG,KACSH,KACtBkD,MAGDY,EAAS,eAACC,yDAAM/D,SACpB2B,EAA2BoC,GAC3B7D,IAAUR,IAAOmD,OAASH,EAAKQ,EAAe,IAAMR,EAAKQ,MAGrDc,EAAa,eAACD,yDAAM/D,SACxB2B,EAA2BoC,GAC3B7D,IAAU,EAAIwC,EAAKQ,GAAgB,IAAMR,EAAKQ,MAG1CF,EAAU,kBAAM9C,IAAUG,IAAYX,IAAOmD,QAE7CI,EAAc,kBAAM/C,IAAU,KA0DtBT,EAAM+C,2BAxDC,cACPtB,IACMA,mBASD,gBACXA,EAAKf,EACL8D,EAAQ1D,EACV2D,EAAEC,OAASvD,EACXsD,EAAEE,OAASzD,EACT0D,EAASzC,EAAU1B,OACNgB,EAAI+C,EAAQI,KAC7BC,kCAZoB,kBACtBhB,EAAkBnD,GAClBwB,EAA2B,kBAyBP,gBACdoC,EAb4B,gBAG5BQ,EADOtD,EADFd,EACgBD,KACRiC,YAEf4B,EAAM,GADIS,KAAKC,IAAIC,IAAa,GACdH,SAClBR,EAAM/D,MACFA,GAED+D,EAIKY,CAA4BT,EAAEQ,UACtCT,EAAQ1D,EAAa2D,EAAEC,OAASD,EAAEE,UAClCI,KAAKC,IAAIR,GAAS7D,EAAWC,IAAYC,EAAkB,IACzDG,EAAMwD,EAAQ,OACRxD,EAAMwD,EAAS,KACdF,MACEtD,EAAML,EAAWC,cAGpBI,EAAMwD,EAAS,KACVF,MACFtD,EAAML,EAAWC,MAGxBmC,MAAMC,iBAAkB,IAC5BzB,gBAEQ+C,KAEGpB,KAAKC,sHA5RX,gBAAEJ,IAAAA,MAAOhD,IAAAA,MAChBA,EAAMoF,oBACFA,iBAAiBpC,GAErBA,EAAMqC,QACJrC,EAAMC,oBACFA,iBAAkB,IAClBoB,cACJ7C,cAIA8D,EAAetC,EAAMtC,UAErBG,QAAQb,EAAMa,SAAW,OACzBF,EAAYqC,EAAMrC,iBACpBA,KACImD,kBAAkBnD,GAEnB4E,EAAE,cAGHzF,EAAQC,OACRC,EAAMwF,OAAS,IACfvD,KAAK,OAGPjC,EAAMyF,OACFF,EAAE,IAAMzF,EAAQ2F,OAAQzF,EAAMyF,QAC9B,KACJF,EAAE,aAESzF,EAAQ4F,iBACL,gBAAEC,IAAAA,IACN3C,EAAMqC,QAGNM,EAAI/D,WAAWyB,OAAS,MACpBuC,aAAaD,KACb7B,kBAAkB6B,KAClBE,MAAQ,IClDP,gBAAGnE,IAAAA,GAAIV,IAAAA,YAAa8E,IAAAA,QAASC,IAAAA,OAAQC,IAAAA,MAClDC,EAAS,IAAIC,OAAOC,QAAQzE,eAC3B0E,IAAI,IAAIF,OAAOG,eACO,aAAhBrF,EACPkF,OAAOI,mBACS,QAAhBtF,EACEkF,OAAOK,cACPL,OAAOM,+BACF,OAENC,GAAG,WAAYX,KACfW,GAAG,UAAWV,KACdU,GAAG,SAAUT,YAGT,aACAU,IAAI,WAAYZ,KAChBY,IAAI,UAAWX,KACfW,IAAI,SAAUV,KDgCC,KACRL,cACS3F,EAAMgB,oBACVgC,EAAM2D,uBACP3D,EAAM4D,iBACP5D,EAAM6D,kBAETxB,QAAS,aAGT,kBAAMrC,EAAM6C,OAAS7C,EAAM6C,MAAMiB,YAE7C9D,EAAM9C,OAAO6G,IAAI,SAACC,EAAMC,UACtBjH,EAAMuD,6CAOVvD,EAAMkH,MACF3B,EAAE,IAAMzF,EAAQoH,MAAOlH,EAAMkH,OAC7B,wDExEI,yDAGY,qCACM,qBAEf"}